<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>High-Fidelity 3D Car Driving Simulator</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
      }
      /* UI Overlay for Dashboard & Controls */
      #ui-overlay {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #0f0;
        font-family: monospace;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }
      #ui-overlay button {
        margin-right: 5px;
      }
    </style>
  </head>
  <body>
    <div id="ui-overlay">
      <div id="dashboard">
        <div id="speed">Speed: 0 km/h</div>
        <div id="rpm">RPM: 0</div>
      </div>
      <div id="controls">
        <button id="replayBtn">Replay</button>
        <button id="photoModeBtn">Photo Mode</button>
      </div>
    </div>
    <script type="module">
      // === Imports from CDN ===
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
      import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
      import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js';
      import { SSAOPass } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/SSAOPass.js';
      import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

      // === Renderer, Scene, and Camera Setup ===
      const canvas = document.createElement('canvas');
      document.body.appendChild(canvas);
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.0005);
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
      camera.position.set(0, 5, -10);

      // === Advanced Post-Processing Setup ===
      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      // UnrealBloomPass for bloom effect
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      composer.addPass(bloomPass);
      // SSAOPass for ambient occlusion
      const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
      ssaoPass.kernelRadius = 16;
      composer.addPass(ssaoPass);

      // === Physics World Setup (using Cannon.js) ===
      const world = new CANNON.World();
      world.gravity.set(0, -9.82, 0);
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;

      // === Procedural Terrain Generation ===
      // A noisy plane is used as a placeholder. Extend this for mountain passes, urban roads, coastal scenes, etc.
      const terrainWidth = 2000, terrainDepth = 2000;
      const terrainGeometry = new THREE.PlaneGeometry(terrainWidth, terrainDepth, 256, 256);
      terrainGeometry.rotateX(-Math.PI / 2);
      // Simple vertex displacement (placeholder for perlin noise or other algorithms)
      for (let i = 0; i < terrainGeometry.attributes.position.count; i++) {
        const vertex = new THREE.Vector3().fromBufferAttribute(terrainGeometry.attributes.position, i);
        vertex.y = Math.sin(vertex.x * 0.005) * 10 + Math.cos(vertex.z * 0.005) * 10;
        terrainGeometry.attributes.position.setY(i, vertex.y);
      }
      terrainGeometry.computeVertexNormals();
      const terrainMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 1 });
      const terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
      terrainMesh.receiveShadow = true;
      scene.add(terrainMesh);

      // Physics body for the terrain (simplified as a static plane)
      const terrainShape = new CANNON.Plane();
      const terrainBody = new CANNON.Body({ mass: 0 });
      terrainBody.addShape(terrainShape);
      terrainBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(terrainBody);

      // === Weather System: Rain Particle System ===
      const rainCount = 15000;
      const rainGeometry = new THREE.BufferGeometry();
      const rainPositions = new Float32Array(rainCount * 3);
      for (let i = 0; i < rainCount; i++) {
        rainPositions[i * 3] = Math.random() * terrainWidth - terrainWidth / 2;
        rainPositions[i * 3 + 1] = Math.random() * 500 + 50;
        rainPositions[i * 3 + 2] = Math.random() * terrainDepth - terrainDepth / 2;
      }
      rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
      const rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.2, transparent: true });
      const rain = new THREE.Points(rainGeometry, rainMaterial);
      scene.add(rain);

      // === Lighting and Day/Night Cycle ===
      const sunLight = new THREE.DirectionalLight(0xffffff, 1);
      sunLight.position.set(50, 200, 100);
      sunLight.castShadow = true;
      scene.add(sunLight);
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      let timeOfDay = 12; // Hours (0-24)
      function updateDayNightCycle(delta) {
        timeOfDay += delta * 0.05;
        if (timeOfDay > 24) timeOfDay -= 24;
        const intensity = Math.max(Math.cos((timeOfDay / 24) * Math.PI * 2), 0.2);
        sunLight.intensity = intensity;
        ambientLight.intensity = intensity * 0.5;
        scene.background = new THREE.Color(intensity < 0.3 ? 0x000022 : 0x87ceeb);
      }

      // === Car Model Loading using GLTFLoader ===
      // Replace the URL with your high-resolution glTF/FBX car model
      let car;
      const loader = new GLTFLoader();
      loader.load(
        'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/models/gltf/Flamingo.glb',
        (gltf) => {
          car = gltf.scene;
          car.scale.set(0.05, 0.05, 0.05);
          car.traverse((child) => {
            if (child.isMesh) child.castShadow = true;
          });
          scene.add(car);
          car.position.set(0, 5, 0);
          // Sync with the physics body below
          carBody.position.set(0, 5, 0);
        },
        undefined,
        (error) => {
          console.error('Error loading car model', error);
          // Fallback: simple box
          const fallbackGeo = new THREE.BoxGeometry(2, 1, 4);
          const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.8, roughness: 0.2 });
          car = new THREE.Mesh(fallbackGeo, fallbackMat);
          car.castShadow = true;
          scene.add(car);
          car.position.set(0, 5, 0);
        }
      );

      // === Car Physics Body (Cannon.js) ===
      const carBodyShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
      const carBody = new CANNON.Body({ mass: 1500 });
      carBody.addShape(carBodyShape);
      carBody.position.set(0, 5, 0);
      world.addBody(carBody);

      // === Realistic AI Cars ===
      const aiCars = [];
      function spawnAICar(x, z) {
        const aiGeo = new THREE.BoxGeometry(2, 1, 4);
        const aiMat = new THREE.MeshStandardMaterial({ color: 0x0000ff, metalness: 0.8, roughness: 0.2 });
        const aiMesh = new THREE.Mesh(aiGeo, aiMat);
        aiMesh.castShadow = true;
        scene.add(aiMesh);
        const aiBody = new CANNON.Body({ mass: 1500 });
        aiBody.addShape(new CANNON.Box(new CANNON.Vec3(1, 0.5, 2)));
        aiBody.position.set(x, 5, z);
        world.addBody(aiBody);
        // Each AI car has a simple target position to follow (enhance with proper pathfinding as needed)
        aiCars.push({ mesh: aiMesh, body: aiBody, target: new THREE.Vector3(0, 5, 0) });
      }
      // Spawn several AI cars
      for (let i = 0; i < 3; i++) {
        spawnAICar(10 * i, 20);
      }
      function updateAICars(delta) {
        aiCars.forEach((ai) => {
          const direction = new THREE.Vector3().subVectors(ai.target, ai.mesh.position).normalize();
          const force = new CANNON.Vec3(direction.x, 0, direction.z).scale(200 * delta);
          ai.body.applyForce(force, ai.body.position);
          ai.mesh.position.copy(ai.body.position);
          ai.mesh.quaternion.copy(ai.body.quaternion);
        });
      }

      // === Car Controls (Keyboard Input) ===
      const keys = {};
      window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
      });
      window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });
      function updateCarControls(delta) {
        const engineForce = 5000;
        const brakeForce = 3000;
        const steerTorque = 0.5;
        // Forward
        if (keys['w'] || keys['arrowup']) {
          const forward = new CANNON.Vec3(-Math.sin(carBody.quaternion.y), 0, -Math.cos(carBody.quaternion.y));
          forward.scale(engineForce * delta, forward);
          carBody.applyLocalForce(forward, new CANNON.Vec3(0, 0, 0));
        }
        // Backward/Brake
        if (keys['s'] || keys['arrowdown']) {
          const backward = new CANNON.Vec3(Math.sin(carBody.quaternion.y), 0, Math.cos(carBody.quaternion.y));
          backward.scale(brakeForce * delta, backward);
          carBody.applyLocalForce(backward, new CANNON.Vec3(0, 0, 0));
        }
        // Steering Left/Right
        if (keys['a'] || keys['arrowleft']) {
          carBody.angularVelocity.y += steerTorque * delta;
        }
        if (keys['d'] || keys['arrowright']) {
          carBody.angularVelocity.y -= steerTorque * delta;
        }
      }

      // === Replay and Photo Mode ===
      let recording = false;
      let recordedFrames = [];
      document.getElementById('replayBtn').addEventListener('click', () => {
        if (recording) {
          recording = false;
          console.log('Replay recorded', recordedFrames.length, 'frames');
          if (recordedFrames.length > 0) {
            const img = new Image();
            img.src = recordedFrames[0];
            const w = window.open("");
            w.document.write(img.outerHTML);
          }
          recordedFrames = [];
        } else {
          recording = true;
          console.log('Recording started...');
        }
      });
      document.getElementById('photoModeBtn').addEventListener('click', () => {
        renderer.render(scene, camera);
        const dataURL = renderer.domElement.toDataURL("image/png");
        const w = window.open("");
        w.document.write('<img src="' + dataURL + '" />');
      });

      // === Web Worker for Offloading Heavy Physics Calculations (Sample) ===
      let physicsWorker;
      if (window.Worker) {
        const workerBlob = new Blob([`
          onmessage = function(e) {
            // Simulate heavy computation (e.g., physics substeps)
            const start = Date.now();
            while (Date.now() - start < 10) {}
            postMessage('done');
          }
        `], { type: 'application/javascript' });
        const workerURL = URL.createObjectURL(workerBlob);
        physicsWorker = new Worker(workerURL);
        physicsWorker.onmessage = function(e) {
          // Worker finished its computationâ€”integrate results if needed
        }
      }

      // === Animation Loop ===
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        updateDayNightCycle(delta);
        updateCarControls(delta);
        updateAICars(delta);

        // Offload dummy heavy physics calculation via Web Worker
        if (physicsWorker) physicsWorker.postMessage('step');

        world.step(1 / 60, delta);

        // Sync car mesh with physics body
        if (car) {
          car.position.copy(carBody.position);
          car.quaternion.copy(carBody.quaternion);
        }

        // Simple rain update: move particles downward and reset when below ground
        const positions = rain.geometry.attributes.position.array;
        for (let i = 0; i < rainCount; i++) {
          positions[i * 3 + 1] -= 0.5;
          if (positions[i * 3 + 1] < 0) positions[i * 3 + 1] = Math.random() * 500 + 50;
        }
        rain.geometry.attributes.position.needsUpdate = true;

        // Camera follows the car smoothly
        camera.position.lerp(new THREE.Vector3(carBody.position.x, carBody.position.y + 5, carBody.position.z - 10), 0.05);
        camera.lookAt(carBody.position);

        // Update UI Dashboard
        const speed = carBody.velocity.length();
        document.getElementById('speed').innerText = 'Speed: ' + Math.round(speed * 3.6) + ' km/h';
        document.getElementById('rpm').innerText = 'RPM: ' + Math.round(speed * 100);

        // Capture frame if recording (for a basic replay demo)
        if (recording && recordedFrames.length < 100) {
          recordedFrames.push(renderer.domElement.toDataURL("image/png"));
        }

        composer.render(delta);
      }
      animate();

      // === Handle Window Resize ===
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
