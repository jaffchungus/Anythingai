<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Realistic Car Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 14px;
        }
        #dashboard {
            position: absolute;
            bottom: 70px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
        }
        #map {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid white;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="hud">
        Speed: 0 km/h | RPM: 0 | Gear: N | Fuel: 100%
    </div>
    <div id="dashboard">
        Oil Pressure: Normal | Water Temp: 25Â°C | Battery: Charged
    </div>
    <div id="controls">
        WASD: Steering/Throttle/Brake | Mouse: Look Around | 
        1-5: Select Car | T: Toggle Camera | 
        F: Handbrake | G: Gear Up | H: Gear Down | 
        V: Toggle View | B: Toggle Map | 
        N: Next Environment | M: Toggle Mouse Look
    </div>
    <div id="map"></div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/DRACOLoader.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { SSAOPass } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/SSAOPass.js';
        import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/ShaderPass.js';
        import { CopyShader } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/shaders/CopyShader.js';
        import { RGBADepthPacking } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/src/constants.js';

        // Physics engine using Cannon.js
        class VehiclePhysics {
            constructor() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.solver.iterations = 10;
                
                this.cars = [];
                this.time = 0;
                this.deltaTime = 0;
                this.lastTime = 0;
            }
            
            update(time) {
                this.deltaTime = (time - this.lastTime) / 1000;
                this.lastTime = time;
                
                this.world.step(this.deltaTime);
                
                this.cars.forEach(car => {
                    car.update(this.deltaTime);
                });
            }
            
            addCar(car) {
                this.cars.push(car);
                this.world.addBody(car.chassis);
                car.wheels.forEach(wheel => this.world.addBody(wheel));
            }
        }

        // Detailed car model with realistic physics
        class RealCar {
            constructor(modelPath, position, color) {
                this.modelPath = modelPath;
                this.position = position;
                this.color = color;
                this.mesh = null;
                this.wheels = [];
                this.chassis = null;
                this.wheelBodies = [];
                this.suspension = [];
                this.steering = 0;
                this.throttle = 0;
                this.brake = 0;
                this.gear = 0;
                this.engineRPMDiv = document.querySelector('#engineRPMDiv');
                
                this.loadModel();
                this.setupPhysics();
            }
            
            loadModel() {
                const loader = new GLTFLoader();
                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                loader.setDRACOLoader(dracoLoader);
                
                loader.load(
                    this.modelPath,
                    (gltf) => {
                        this.mesh = gltf.scene;
                        this.mesh.position.copy(this.position);
                        this.mesh.scale.set(0.01, 0.01, 0.01); // Scale down the model
                        this.mesh.traverse((child) => {
                            if (child.isMesh) {
                                child.material.color.set(this.color);
                                if (child.name.includes('wheel')) {
                                    this.wheels.push(child);
                                }
                            }
                        });
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading car model:', error);
                        // Create a simple cube as fallback
                        this.mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(4, 1.5, 2),
                            new THREE.MeshStandardMaterial({ color: this.color })
                        );
                        this.mesh.position.copy(this.position);
                        this.mesh.name = 'fallbackCar';
                    }
                );
            }
            
            setupPhysics() {
                // Chassis
                this.chassis = new CANNON.Body({
                    mass: 1500,
                    shape: new CANNON.Box(new CANNON.Vec3(2, 1, 4)),
                    position: new CANNON.Vec3(this.position.x, this.position.y, this.position.z)
                });
                
                // Wheels
                const wheelRadius = 0.3;
                const wheelWidth = 0.2;
                const wheelMass = 20;
                
                // Front left wheel
                const flWheel = new CANNON.Body({
                    mass: wheelMass,
                    shape: new CANNON.Cylinder(wheelRadius, wheelRadius, wheelWidth, 24)
                });
                flWheel.position = new CANNON.Vec3(-1.5, -0.5, 1.5);
                this.wheelBodies.push(flWheel);
                
                // Front right wheel
                const frWheel = new CANNON.Body({
                    mass: wheelMass,
                    shape: new CANNON.Cylinder(wheelRadius, wheelRadius, wheelWidth, 24)
                });
                frWheel.position = new CANNON.Vec3(1.5, -0.5, 1.5);
                this.wheelBodies.push(frWheel);
                
                // Rear left wheel
                const rlWheel = new CANNON.Body({
                    mass: wheelMass,
                    shape: new CANNON.Cylinder(wheelRadius, wheelRadius, wheelWidth, 24)
                });
                rlWheel.position = new CANNON.Vec3(-1.5, -0.5, -1.5);
                this.wheelBodies.push(rlWheel);
                
                // Rear right wheel
                const rrWheel = new CANNON.Body({
                    mass: wheelMass,
                    shape: new CANNON.Cylinder(wheelRadius, wheelRadius, wheelWidth, 24)
                });
                rrWheel.position = new CANNON.Vec3(1.5, -0.5, -1.5);
                this.wheelBodies.push(rrWheel);
                
                // Suspension setup
                this.suspension = [
                    { stiffness: 50, damping: 5, restLength: 0.3 }, // FL
                    { stiffness: 50, damping: 5, restLength: 0.3 }, // FR
                    { stiffness: 50, damping: 5, restLength: 0.3 }, // RL
                    { stiffness: 50, damping: 5, restLength: 0.3 }  // RR
                ];
                
                // Create suspension constraints
                this.suspensionConstraints = [];
                for (let i = 0; i < 4; i++) {
                    const constraint = new CANNON.DistanceConstraint(
                        this.chassis,
                        this.wheelBodies[i],
                        this.suspension[i].restLength
                    );
                    this.suspensionConstraints.push(constraint);
                }
            }
            
            update(deltaTime) {
                if (!this.mesh) return;
                
                // Update visual position from physics
                this.mesh.position.copy(this.chassis.position);
                this.mesh.quaternion.copy(this.chassis.quaternion);
                
                // Update wheel positions
                for (let i = 0; i < 4; i++) {
                    const wheel = this.wheelBodies[i];
                    const visualWheel = this.wheels[i];
                    
                    visualWheel.position.copy(wheel.position);
                    visualWheel.quaternion.copy(wheel.quaternion);
                    
                    // Update wheel rotation
                    visualWheel.rotation.x += this.chassis.velocity.z * 0.01;
                }
                
                // Simple engine simulation
                let enginePower = 0;
                if (this.gear !== 0 && this.throttle !== 0) {
                    const maxTorque = 1000;
                    enginePower = maxTorque * this.throttle * (this.gear > 0 ? 1 : -1);
                }
                
                // Apply engine force to rear wheels
                this.wheelBodies[2].applyForce(
                    new CANNON.Vec3(0, 0, -enginePower),
                    this.wheelBodies[2].position
                );
                this.wheelBodies[3].applyForce(
                    new CANNON.Vec3(0, 0, -enginePower),
                    this.wheelBodies[3].position
                );
                
                // Apply brake force
                if (this.brake !== 0) {
                    for (let i = 0; i < 4; i++) {
                        this.wheelBodies[i].applyForce(
                            new CANNON.Vec3(0, 0, this.brake * 5000),
                            this.wheelBodies[i].position
                        );
                    }
                }
                
                // Update HUD
                const speed = this.chassis.velocity.length() * 3.6; // m/s to km/h
                const rpm = Math.abs(this.gear) * 2000 + this.throttle * 6000;
                document.getElementById('hud').textContent = 
                    `Speed: ${speed.toFixed(0)} km/h | RPM: ${rpm.toFixed(0)} | Gear: ${this.gear} | Fuel: 100%`;
            }
            
            steer(value) {
                this.steering = value;
                // Front wheels steering
                const angle = value * 0.3;
                this.wheelBodies[0].quaternion.setFromAxisAngle(
                    new CANNON.Vec3(0, 1, 0),
                    angle
                );
                this.wheelBodies[1].quaternion.setFromAxisAngle(
                    new CANNON.Vec3(0, 1, 0),
                    angle
                );
            }
            
            accelerate(value) {
                this.throttle = value;
            }
            
            brake(value) {
                this.brake = value;
            }
            
            shiftGear(gear) {
                this.gear = gear;
            }
        }

        class CarSimulator {
            constructor() {
                // Initialize Three.js scene
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(this.renderer.domElement);
                
                // Setup post-processing
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85
                );
                const ssaoPass = new SSAOPass(this.scene, this.camera, 512, 512);
                
                this.composer.addPass(renderPass);
                this.composer.addPass(ssaoPass);
                this.composer.addPass(bloomPass);
                
                // Initialize physics
                this.physics = new VehiclePhysics();
                
                // Setup environment
                this.environments = [
                    this.createMountainPass,
                    this.createRuralLandscape,
                    this.createUrbanHighway,
                    this.createCoastalRoad,
                    this.createSuburbanArea
                ];
                this.currentEnvironment = 0;
                this.environment = this.environments[this.currentEnvironment]();
                
                // Load cars
                this.cars = [];
                this.currentCarIndex = 0;
                this.loadCars();
                
                // Setup camera
                this.cameraMode = 'thirdPerson';
                this.setupCamera();
                
                // Setup controls
                this.setupControls();
                
                // Setup resize handler
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Start animation loop
                this.lastTime = performance.now();
                this.animate();
            }
            
            createMountainPass() {
                // Ground with height variation
                const groundGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
                groundGeometry.rotateX(-Math.PI / 2);
                
                groundGeometry.attributes.position.array.forEach((v, i) => {
                    if (i % 3 === 1) {
                        groundGeometry.attributes.position.array[i] = Math.sin(v * 0.01) * Math.cos(v * 0.01) * 30;
                    }
                });
                groundGeometry.attributes.position.needsUpdate = true;
                
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88aa88,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Road
                const roadGeometry = new THREE.PlaneGeometry(200, 5);
                roadGeometry.rotateX(-Math.PI / 2);
                const roadMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.9
                });
                
                for (let i = -100; i < 100; i += 10) {
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(0, 0.1, i * 10);
                    road.receiveShadow = true;
                    this.scene.add(road);
                }
                
                // Skybox
                const skyboxGeometry = new THREE.BoxGeometry(2000, 2000, 2000);
                const skyboxMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                this.scene.add(skybox);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                return {
                    name: "Mountain Pass",
                    weather: "clear"
                };
            }
            
            createRuralLandscape() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
                groundGeometry.rotateX(-Math.PI / 2);
                
                const groundTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg');
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(100, 100);
                
                const groundMaterial = new THREE.MeshStandardMaterial({
                    map: groundTexture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Trees
                const treeGeometry = new THREE.ConeGeometry(1, 2, 8);
                const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x33aa33 });
                
                for (let i = 0; i < 200; i++) {
                    const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                    tree.position.set(
                        Math.random() * 1000 - 500,
                        0,
                        Math.random() * 1000 - 500
                    );
                    this.scene.add(tree);
                }
                
                // Road
                const roadGeometry = new THREE.PlaneGeometry(200, 5);
                roadGeometry.rotateX(-Math.PI / 2);
                const roadMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.9
                });
                
                for (let i = -100; i < 100; i += 10) {
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(0, 0.1, i * 10);
                    road.receiveShadow = true;
                    this.scene.add(road);
                }
                
                // Skybox
                const skyboxGeometry = new THREE.BoxGeometry(2000, 2000, 2000);
                const skyboxMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                this.scene.add(skybox);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                return {
                    name: "Rural Landscape",
                    weather: "clear"
                };
            }
            
            createUrbanHighway() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
                groundGeometry.rotateX(-Math.PI / 2);
                
                const groundTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/asphalt.jpg');
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(100, 100);
                
                const groundMaterial = new THREE.MeshStandardMaterial({
                    map: groundTexture,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Buildings
                for (let i = 0; i < 50; i++) {
                    const width = Math.random() * 10 + 5;
                    const depth = Math.random() * 10 + 5;
                    const height = Math.random() * 80 + 20;
                    
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const buildingMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(`hsl(${Math.random() * 360}, 70%, 70%)`),
                        roughness: 0.8
                    });
                    
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.set(
                        Math.random() * 800 - 400,
                        height / 2,
                        Math.random() * 800 - 400
                    );
                    building.castShadow = true;
                    building.receiveShadow = true;
                    this.scene.add(building);
                }
                
                // Highway
                const highwayGeometry = new THREE.PlaneGeometry(2000, 50);
                highwayGeometry.rotateX(-Math.PI / 2);
                const highwayMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    roughness: 0.9
                });
                
                const highway = new THREE.Mesh(highwayGeometry, highwayMaterial);
                highway.position.z = 0;
                highway.receiveShadow = true;
                this.scene.add(highway);
                
                // Skybox
                const skyboxGeometry = new THREE.BoxGeometry(2000, 2000, 2000);
                const skyboxMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                this.scene.add(skybox);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                return {
                    name: "Urban Highway",
                    weather: "clear"
                };
            }
            
            createCoastalRoad() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
                groundGeometry.rotateX(-Math.PI / 2);
                
                const groundTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg');
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(100, 100);
                
                const groundMaterial = new THREE.MeshStandardMaterial({
                    map: groundTexture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Ocean
                const oceanGeometry = new THREE.PlaneGeometry(2000, 2000);
                oceanGeometry.rotateX(-Math.PI / 2);
                const oceanMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0077ff,
                    transparent: true,
                    opacity: 0.8,
                    roughness: 0.1,
                    metalness: 0.9
                });
                
                const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
                ocean.position.z = -500;
                ocean.receiveShadow = true;
                this.scene.add(ocean);
                
                // Road
                const roadGeometry = new THREE.PlaneGeometry(200, 5);
                roadGeometry.rotateX(-Math.PI / 2);
                const roadMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.9
                });
                
                for (let i = -100; i < 100; i += 10) {
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(0, 0.1, i * 10);
                    road.receiveShadow = true;
                    this.scene.add(road);
                }
                
                // Skybox
                const skyboxGeometry = new THREE.BoxGeometry(2000, 2000, 2000);
                const skyboxMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                this.scene.add(skybox);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                return {
                    name: "Coastal Road",
                    weather: "clear"
                };
            }
            
            createSuburbanArea() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
                groundGeometry.rotateX(-Math.PI / 2);
                
                const groundTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg');
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(100, 100);
                
                const groundMaterial = new THREE.MeshStandardMaterial({
                    map: groundTexture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Houses
                for (let i = 0; i < 30; i++) {
                    const width = Math.random() * 8 + 4;
                    const depth = Math.random() * 8 + 4;
                    const height = Math.random() * 10 + 5;
                    
                    const houseGeometry = new THREE.BoxGeometry(width, height, depth);
                    const houseMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(`hsl(${Math.random() * 360}, 70%, 70%)`),
                        roughness: 0.8
                    });
                    
                    const house = new THREE.Mesh(houseGeometry, houseMaterial);
                    house.position.set(
                        Math.random() * 800 - 400,
                        height / 2,
                        Math.random() * 800 - 400
                    );
                    house.castShadow = true;
                    house.receiveShadow = true;
                    this.scene.add(house);
                }
                
                // Roads
                const roadGeometry = new THREE.PlaneGeometry(200, 5);
                roadGeometry.rotateX(-Math.PI / 2);
                const roadMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.9
                });
                
                for (let i = -100; i < 100; i += 20) {
                    const road = new THREE.Mesh(roadGeometry, roadMaterial);
                    road.position.set(0, 0.1, i * 10);
                    road.receiveShadow = true;
                    this.scene.add(road);
                }
                
                // Skybox
                const skyboxGeometry = new THREE.BoxGeometry(2000, 2000, 2000);
                const skyboxMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                this.scene.add(skybox);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                return {
                    name: "Suburban Area",
                    weather: "clear"
                };
            }
            
            loadCars() {
                // Load multiple car models
                const carModels = [
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0xff0000 },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0x00ff00 },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0x0000ff },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0xffff00 },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0xff00ff }
                ];
                
                carModels.forEach((model, index) => {
                    const car = new RealCar(model.path, new THREE.Vector3(0, 1.5, 0), model.color);
                    this.cars.push(car);
                    this.scene.add(car.mesh);
                    
                    if (index > 0) {
                        car.mesh.visible = false;
                    } else {
                        this.physics.addCar(car);
                    }
                });
            }
            
            setupCamera() {
                this.camera.position.set(0, 5, -10);
                this.camera.lookAt(0, 0, 0);
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enabled = false;
            }
            
            setupControls() {
                const handleKeyDown = (event) => {
                    const car = this.cars[this.currentCarIndex];
                    
                    switch(event.key) {
                        case 'w':
                        case 'W':
                            car.accelerate(1);
                            break;
                        case 's':
                        case 'S':
                            car.accelerate(-0.5);
                            break;
                        case 'a':
                        case 'A':
                            car.steer(-1);
                            break;
                        case 'd':
                        case 'D':
                            car.steer(1);
                            break;
                        case ' ':
                            car.brake(1);
                            break;
                        case 't':
                        case 'T':
                            this.toggleCameraMode();
                            break;
                        case '1':
                            this.selectCar(0);
                            break;
                        case '2':
                            this.selectCar(1);
                            break;
                        case '3':
                            this.selectCar(2);
                            break;
                        case '4':
                            this.selectCar(3);
                            break;
                        case '5':
                            this.selectCar(4);
                            break;
                        case 'g':
                        case 'G':
                            car.shiftGear(car.gear > 0 ? car.gear + 1 : -car.gear + 1);
                            break;
                        case 'h':
                        case 'H':
                            car.shiftGear(car.gear > 0 ? car.gear - 1 : -car.gear - 1);
                            break;
                        case 'v':
                        case 'V':
                            this.toggleCameraView();
                            break;
                        case 'b':
                        case 'B':
                            this.toggleMap();
                            break;
                        case 'n':
                        case 'N':
                            this.nextEnvironment();
                            break;
                        case 'm':
                        case 'M':
                            this.toggleMouseLook();
                            break;
                    }
                };
                
                const handleKeyUp = (event) => {
                    const car = this.cars[this.currentCarIndex];
                    
                    switch(event.key) {
                        case 'w':
                        case 'W':
                        case 's':
                        case 'S':
                            car.accelerate(0);
                            break;
                        case 'a':
                        case 'A':
                        case 'd':
                        case 'D':
                            car.steer(0);
                            break;
                        case ' ':
                            car.brake(0);
                            break;
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'm' || event.key === 'M') {
                        this.toggleMouseLook();
                    }
                });
                
                this.mouseLookEnabled = false;
            }
            
            toggleMouseLook() {
                this.mouseLookEnabled = !this.mouseLookEnabled;
                this.controls.enabled = !this.mouseLookEnabled;
                
                if (this.mouseLookEnabled) {
                    document.addEventListener('mousemove', this.onMouseMove);
                } else {
                    document.removeEventListener('mousemove', this.onMouseMove);
                }
            }
            
            onMouseMove = (event) => {
                if (!this.mouseLookEnabled) return;
                
                event.preventDefault();
                
                const car = this.cars[this.currentCarIndex];
                
                const windowHalfX = window.innerWidth / 2;
                const windowHalfY = window.innerHeight / 2;
                
                const deltaX = event.clientX - windowHalfX;
                const deltaY = event.clientY - windowHalfY;
                
                car.steer(-deltaX * 0.002);
                this.camera.rotation.x -= deltaY * 0.001;
                
                event.clientX = windowHalfX;
                event.clientY = windowHalfY;
            }
            
            toggleCameraMode() {
                if (this.cameraMode === 'thirdPerson') {
                    this.cameraMode = 'firstPerson';
                    this.camera.position.set(0, 1.7, 0);
                } else {
                    this.cameraMode = 'thirdPerson';
                    this.camera.position.set(0, 3, -5);
                }
                this.camera.lookAt(this.cars[this.currentCarIndex].mesh.position);
            }
            
            toggleCameraView() {
                if (this.cameraMode === 'thirdPerson') {
                    this.cameraMode = 'firstPerson';
                    this.camera.position.set(0, 1.7, 0);
                } else if (this.cameraMode === 'firstPerson') {
                    this.cameraMode = 'cockpit';
                    this.camera.position.set(0, 1.2, 0);
                } else {
                    this.cameraMode = 'thirdPerson';
                    this.camera.position.set(0, 3, -5);
                }
                this.camera.lookAt(this.cars[this.currentCarIndex].mesh.position);
            }
            
            selectCar(index) {
                if (index < 0 || index >= this.cars.length) return;
                
                this.currentCarIndex = index;
                
                this.cars.forEach((car, i) => {
                    car.mesh.visible = i === index;
                });
                
                if (this.cameraMode === 'firstPerson') {
                    this.camera.position.set(0, 1.7, 0);
                } else if (this.cameraMode === 'cockpit') {
                    this.camera.position.set(0, 1.2, 0);
                } else {
                    this.camera.position.set(0, 3, -5);
                }
                this.camera.lookAt(this.cars[this.currentCarIndex].mesh.position);
                
                // Remove previous car from physics and add new one
                if (this.currentCarIndex > 0) {
                    this.physics.world.removeBody(this.cars[this.currentCarIndex - 1].chassis);
                    this.cars[this.currentCarIndex - 1].wheelBodies.forEach(wheel => {
                        this.physics.world.removeBody(wheel);
                    });
                }
                
                this.physics.addCar(this.cars[this.currentCarIndex]);
            }
            
            toggleMap() {
                const map = document.getElementById('map');
                map.style.display = map.style.display === 'none' ? 'block' : 'none';
            }
            
            nextEnvironment() {
                this.currentEnvironment = (this.currentEnvironment + 1) % this.environments.length;
                this.environment = this.environments[this.currentEnvironment]();
                
                // Clear scene and add new environment
                while (this.scene.children.length > 0) {
                    this.scene.remove(this.scene.children[0]);
                }
                
                this.environment = this.environments[this.currentEnvironment]();
                this.loadCars();
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
            
            updateCamera() {
                const car = this.cars[this.currentCarIndex];
                
                if (!car.mesh) return;
                
                if (this.cameraMode === 'thirdPerson') {
                    this.camera.position.x = car.mesh.position.x - Math.sin(car.mesh.rotation.y) * 5;
                    this.camera.position.y = car.mesh.position.y + 2;
                    this.camera.position.z = car.mesh.position.z + Math.cos(car.mesh.rotation.y) * 5;
                    this.camera.lookAt(car.mesh.position);
                } else if (this.cameraMode === 'firstPerson') {
                    this.camera.position.x = car.mesh.position.x;
                    this.camera.position.y = car.mesh.position.y + 1.5;
                    this.camera.position.z = car.mesh.position.z;
                    this.camera.quaternion.copy(car.mesh.quaternion);
                } else if (this.cameraMode === 'cockpit') {
                    this.camera.position.x = car.mesh.position.x;
                    this.camera.position.y = car.mesh.position.y + 1.2;
                    this.camera.position.z = car.mesh.position.z;
                    this.camera.quaternion.copy(car.mesh.quaternion);
                }
            }
            
            animate() {
                requestAnimationFrame((time) => this.animate());
                
                const deltaTime = (time - this.lastTime) / 1000;
                this.lastTime = time;
                
                this.physics.update(time);
                this.updateCamera();
                
                this.renderer.render(this.scene, this.camera);
                this.composer.render();
            }
        }

        window.addEventListener('load', () => {
            new CarSimulator();
        });
    </script>
</body>
</html>
