<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Car Driving Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="hud">Speed: 0 km/h | Gear: N</div>
    <div id="controls">
        WASD: Move | Mouse: Look | 1-5: Select Car | T: Toggle Camera | Space: Handbrake
    </div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/loaders/GLTFLoader.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { SSAOPass } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/postprocessing/SSAOPass.js';

        class PhysicsEngine {
            constructor() {
                this.cars = [];
                this.time = 0;
                this.deltaTime = 0;
                this.lastTime = 0;
            }
            
            update(time) {
                this.deltaTime = (time - this.lastTime) / 1000;
                this.lastTime = time;
                
                this.cars.forEach(car => {
                    car.update(this.deltaTime);
                });
            }
            
            addCar(car) {
                this.cars.push(car);
            }
        }

        class Car {
            constructor(modelPath, position, color) {
                this.modelPath = modelPath;
                this.position = position;
                this.color = color;
                this.mesh = null;
                this.wheels = [];
                this.speed = 0;
                this.steeringAngle = 0;
                this.targetSpeed = 0;
                this.gear = 'N';
                this.handbrake = false;
                
                this.loadModel();
            }
            
            loadModel() {
                const loader = new GLTFLoader();
                loader.load(this.modelPath, (gltf) => {
                    this.mesh = gltf.scene;
                    this.mesh.position.copy(this.position);
                    this.mesh.scale.set(0.5, 0.5, 0.5); // Scale down the model
                    this.mesh.traverse((child) => {
                        if (child.isMesh) {
                            child.material.color.set(this.color);
                            if (child.name.includes('wheel')) {
                                this.wheels.push(child);
                            }
                        }
                    });
                }, undefined, (error) => {
                    console.error('Error loading car model:', error);
                    // Create a simple cube as fallback
                    this.mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 1, 4),
                        new THREE.MeshStandardMaterial({ color: this.color })
                    );
                    this.mesh.position.copy(this.position);
                    this.mesh.name = 'fallbackCar';
                });
            }
            
            update(deltaTime) {
                if (!this.mesh) return;
                
                const acceleration = 50;
                const braking = 100;
                const friction = 5;
                
                if (this.targetSpeed > this.speed) {
                    this.speed = Math.min(this.speed + acceleration * deltaTime, this.targetSpeed);
                } else if (this.targetSpeed < this.speed) {
                    this.speed = Math.max(this.speed - braking * deltaTime, this.targetSpeed);
                }
                
                if (Math.abs(this.speed) > 0.1) {
                    this.speed -= this.speed * friction * deltaTime;
                } else {
                    this.speed = 0;
                }
                
                const direction = new THREE.Vector3(
                    Math.sin(this.mesh.rotation.y),
                    0,
                    Math.cos(this.mesh.rotation.y)
                ).multiplyScalar(this.speed * deltaTime);
                
                this.mesh.position.add(direction);
                
                this.wheels.forEach(wheel => {
                    wheel.rotation.x += this.speed * 0.01;
                });
                
                document.getElementById('hud').textContent = 
                    `Speed: ${Math.round(this.speed * 3.6)} km/h | Gear: ${this.gear}`;
            }
            
            accelerate(amount) {
                this.targetSpeed = amount;
            }
            
            steer(angle) {
                this.steeringAngle = angle;
                this.mesh.rotation.y += angle * 0.02;
            }
            
            setGear(gear) {
                this.gear = gear;
            }
            
            toggleHandbrake() {
                this.handbrake = !this.handbrake;
            }
        }

        class CarSimulator {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(this.renderer.domElement);
                
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85
                );
                
                this.composer.addPass(renderPass);
                this.composer.addPass(bloomPass);
                
                this.physics = new PhysicsEngine();
                this.setupEnvironment();
                this.cars = [];
                this.currentCarIndex = 0;
                this.loadCars();
                this.setupCamera();
                this.setupControls();
                window.addEventListener('resize', () => this.onWindowResize());
                this.lastTime = performance.now();
                this.animate();
            }
            
            setupEnvironment() {
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88cc88,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
                const skyboxMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87ceeb,
                    side: THREE.BackSide
                });
                const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                this.scene.add(skybox);
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
            }
            
            loadCars() {
                const carModels = [
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0xff0000 },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0x00ff00 },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0x0000ff },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0xffff00 },
                    { path: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Van/glTF/Van.gltf', color: 0xff00ff }
                ];
                
                carModels.forEach((model, index) => {
                    const car = new Car(model.path, new THREE.Vector3(0, 1.5, 0), model.color);
                    this.cars.push(car);
                    this.scene.add(car.mesh);
                    
                    if (index > 0) {
                        car.mesh.visible = false;
                    }
                });
                
                if (this.cars[0].mesh) {
                    this.physics.addCar(this.cars[0]);
                }
            }
            
            setupCamera() {
                this.camera.position.set(0, 5, -10);
                this.camera.lookAt(0, 0, 0);
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enabled = false;
            }
            
            setupControls() {
                const handleKeyDown = (event) => {
                    const car = this.cars[this.currentCarIndex];
                    
                    switch(event.key) {
                        case 'w':
                        case 'W':
                            car.accelerate(20);
                            break;
                        case 's':
                        case 'S':
                            car.accelerate(-10);
                            break;
                        case 'a':
                        case 'A':
                            car.steer(-1);
                            break;
                        case 'd':
                        case 'D':
                            car.steer(1);
                            break;
                        case ' ':
                            car.toggleHandbrake();
                            break;
                        case 't':
                        case 'T':
                            this.toggleCameraMode();
                            break;
                        case '1':
                            this.selectCar(0);
                            break;
                        case '2':
                            this.selectCar(1);
                            break;
                        case '3':
                            this.selectCar(2);
                            break;
                        case '4':
                            this.selectCar(3);
                            break;
                        case '5':
                            this.selectCar(4);
                            break;
                    }
                };
                
                const handleKeyUp = (event) => {
                    const car = this.cars[this.currentCarIndex];
                    
                    switch(event.key) {
                        case 'w':
                        case 'W':
                        case 's':
                        case 'S':
                            car.accelerate(0);
                            break;
                        case 'a':
                        case 'A':
                        case 'd':
                        case 'D':
                            car.steer(0);
                            break;
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'm' || event.key === 'M') {
                        this.toggleMouseLook();
                    }
                });
                
                this.mouseLookEnabled = false;
            }
            
            toggleMouseLook() {
                this.mouseLookEnabled = !this.mouseLookEnabled;
                this.controls.enabled = !this.mouseLookEnabled;
                
                if (this.mouseLookEnabled) {
                    document.addEventListener('mousemove', this.onMouseMove);
                } else {
                    document.removeEventListener('mousemove', this.onMouseMove);
                }
            }
            
            onMouseMove = (event) => {
                if (!this.mouseLookEnabled) return;
                
                event.preventDefault();
                
                const car = this.cars[this.currentCarIndex];
                
                const windowHalfX = window.innerWidth / 2;
                const windowHalfY = window.innerHeight / 2;
                
                const deltaX = event.clientX - windowHalfX;
                const deltaY = event.clientY - windowHalfY;
                
                car.mesh.rotation.y -= deltaX * 0.002;
                this.camera.rotation.x -= deltaY * 0.001;
                
                event.clientX = windowHalfX;
                event.clientY = windowHalfY;
            }
            
            toggleCameraMode() {
                if (this.cameraMode === 'thirdPerson') {
                    this.cameraMode = 'firstPerson';
                    this.camera.position.set(0, 1.7, 0);
                } else {
                    this.cameraMode = 'thirdPerson';
                    this.camera.position.set(0, 3, -5);
                }
                this.camera.lookAt(this.cars[this.currentCarIndex].mesh.position);
            }
            
            selectCar(index) {
                if (index < 0 || index >= this.cars.length) return;
                
                this.currentCarIndex = index;
                
                this.cars.forEach((car, i) => {
                    car.mesh.visible = i === index;
                });
                
                if (this.cameraMode === 'firstPerson') {
                    this.camera.position.set(0, 1.7, 0);
                } else {
                    this.camera.position.set(0, 3, -5);
                }
                this.camera.lookAt(this.cars[this.currentCarIndex].mesh.position);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
            
            updateCamera() {
                const car = this.cars[this.currentCarIndex];
                
                if (!car.mesh) return;
                
                if (this.cameraMode === 'thirdPerson') {
                    this.camera.position.x = car.mesh.position.x - Math.sin(car.mesh.rotation.y) * 5;
                    this.camera.position.y = car.mesh.position.y + 2;
                    this.camera.position.z = car.mesh.position.z + Math.cos(car.mesh.rotation.y) * 5;
                    this.camera.lookAt(car.mesh.position);
                } else if (this.cameraMode === 'firstPerson') {
                    this.camera.position.x = car.mesh.position.x;
                    this.camera.position.y = car.mesh.position.y + 1.5;
                    this.camera.position.z = car.mesh.position.z;
                    this.camera.rotation.y = car.mesh.rotation.y;
                }
            }
            
            animate() {
                requestAnimationFrame((time) => this.animate());
                
                const deltaTime = (time - this.lastTime) / 1000;
                this.lastTime = time;
                
                this.physics.update(time);
                this.updateCamera();
                
                this.renderer.render(this.scene, this.camera);
                this.composer.render();
            }
        }

        window.addEventListener('load', () => {
            new CarSimulator();
        });
    </script>
</body>
</html>
